<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Programming on Recology</title>
    <link>http://localhost:1313/tags/programming/</link>
    <description>Recent content in Programming on Recology</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 18 Apr 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python, ast, and redbaron</title>
      <link>http://localhost:1313/2023/04/python-ast/</link>
      <pubDate>Tue, 18 Apr 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2023/04/python-ast/</guid>
      <description>I recently had a use case at work where I wanted to check that file paths given in a Python script actually existed. These paths were in various GitHub repositories, so all I had to do was pull out the paths and check if they exist on GitHub.
There were a few catches though.
First, I couldn&amp;rsquo;t simply get any string out of each Python script - they needed to be strings specficied by a specific function parameter, and match a regex (e.</description>
      <content:encoded><![CDATA[<p>I recently had a use case at work where I wanted to check that file paths given in a Python script actually existed. These paths were in various GitHub repositories, so all I had to do was pull out the paths and check if they exist on GitHub.</p>
<p>There were a few catches though.</p>
<p>First, I couldn&rsquo;t simply get any string out of each Python script - they needed to be strings specficied by a specific function parameter, and match a regex (e.g., start with &lsquo;abc&rsquo;).</p>
<p>Second, the script paths lack the GitHub repository root name. This name was part of the function name - so I needed to get access to the function that the path was specified within, and then parse the function name to get the repository name.</p>
<p>The obvious solution I thought was the <a href="https://docs.python.org/3/library/ast.html">ast</a> library.</p>
<h2 id="ast-library">ast library</h2>
<p>I started by using <code>ast</code>. The <code>ast.NodeVisitor</code> class seemed like it would do the trick.</p>
<p>An example script (&ldquo;my_script.py&rdquo;):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hello</span>(path, stuff<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> path
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    print(hello(path<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;hello/world.py&#34;</span>, stuff<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;hello mars&#34;</span>))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> ast
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CollectStrings</span>(ast<span style="color:#f92672">.</span>NodeVisitor):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">visit_Module</span>(self, node):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>out <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>generic_visit(node)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> list(filter(<span style="color:#66d9ef">lambda</span> w: w<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#34;hello&#34;</span>) <span style="color:#f92672">and</span> w<span style="color:#f92672">.</span>endswith(<span style="color:#e6db74">&#34;.py&#34;</span>), self<span style="color:#f92672">.</span>out))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">visit_Str</span>(self, node):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>out<span style="color:#f92672">.</span>add(node<span style="color:#f92672">.</span>s)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>file <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;my_script.py&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(file, <span style="color:#e6db74">&#34;r&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    body <span style="color:#f92672">=</span> ast<span style="color:#f92672">.</span>parse(f<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>coll <span style="color:#f92672">=</span> CollectStrings()
</span></span><span style="display:flex;"><span>coll<span style="color:#f92672">.</span>visit(body)
</span></span><span style="display:flex;"><span><span style="color:#75715e">## [&#39;hello/world.py&#39;]</span>
</span></span></code></pre></div><p>That worked great at fetching paths - only because all the paths I was looking for started with the same text and all have the same file extension.</p>
<p>HOWEVER - I also needed the function name that the <code>path</code> argument was called from. I tried to make this work with <code>ast.NodeVisitor</code> but couldn&rsquo;t get it to work.</p>
<p>I eventually got frustrated enough and figured there must be some libraries that build on top of <code>ast</code> that make it easier to work with ast&rsquo;s in Python.</p>
<h2 id="redbaron">redbaron</h2>
<p>Enter <a href="https://github.com/PyCQA/redbaron">redbaron</a>. I found this library pretty quickly upon searching for a library building on top of <code>ast</code>.</p>
<p>Another example script (&ldquo;their_script.py&rdquo;):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hello</span>(path, stuff<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> path
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">goodbye</span>(path, stuff<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> path
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">world</span>():
</span></span><span style="display:flex;"><span>    path_str <span style="color:#f92672">=</span> hello(path<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;src/world.py&#34;</span>, stuff<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;hello mars&#34;</span>)
</span></span><span style="display:flex;"><span>    other_path_str <span style="color:#f92672">=</span> goodbye(path<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;src/world.py&#34;</span>, stuff<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;hello saturn&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> path_str, other_path_str
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    print(world())
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> re
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> redbaron <span style="color:#f92672">import</span> RedBaron
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>file <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;their_script.py&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(file, <span style="color:#e6db74">&#34;r&#34;</span>) <span style="color:#66d9ef">as</span> src:
</span></span><span style="display:flex;"><span>  red <span style="color:#f92672">=</span> RedBaron(src<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>red
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 0   def hello(path, stuff=None):</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##         return path</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 1   def goodbye(path, stuff=None):</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##         return path</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 2   def world():</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##         path_str = hello(path=&#34;src/world.py&#34;, stuff=&#34;hello mars&#34;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##         other_path_str = goodbye(path=&#34;src/world.py&#34;, stuff=&#34;hello saturn&#34;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##         return path_str, other_path_str</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 3   if __name__ == &#34;__main__&#34;:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##         print(world())</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## </span>
</span></span></code></pre></div><p>Even just the resulting object you get from parsing something is useful:</p>
<p>And with <code>.help()</code> you get a very detailed map of the structure of the thing you&rsquo;re trying to navigate (only printing first 20 lines):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>red<span style="color:#f92672">.</span>help()
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 0 -----------------------------------------------------</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## DefNode()</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##   # identifiers: def, def_, defnode, funcdef, funcdef_</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##   # default test value: name</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##   async=False</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##   name=&#39;hello&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##   return_annotation -&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     None</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##   decorators -&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##   arguments -&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     * DefArgumentNode()</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##         # identifiers: def_argument, def_argument_, defargument, defargumentnode</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##         target -&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##           NameNode() ...</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##         annotation -&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##           None</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##         value -&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##           None</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##     * DefArgumentNode()</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##         # identifiers: def_argument, def_argument_, defargument, defargumentnode</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span></code></pre></div><p>Looking at the result from <code>red.help()</code> I can then use <code>.find_all()</code> to find certain nodes in the ast.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>nodes <span style="color:#f92672">=</span> red<span style="color:#f92672">.</span>find_all(<span style="color:#e6db74">&#34;AtomtrailersNode&#34;</span>)
</span></span><span style="display:flex;"><span>nodes <span style="color:#f92672">=</span> list(filter(<span style="color:#66d9ef">lambda</span> w: <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">in</span> w<span style="color:#f92672">.</span>dumps(), nodes))
</span></span><span style="display:flex;"><span>nodes
</span></span><span style="display:flex;"><span><span style="color:#75715e">## [hello(path=&#34;src/world.py&#34;, stuff=&#34;hello mars&#34;), goodbye(path=&#34;src/world.py&#34;, stuff=&#34;hello saturn&#34;)]</span>
</span></span></code></pre></div><p>Then I can write some okay code to extract out the function name, and ugly code to get the string supplied to the <code>path</code> parameter. Then f-string those together to get the path I&rsquo;m after.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>paths <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> node <span style="color:#f92672">in</span> nodes:
</span></span><span style="display:flex;"><span>    fxn_name <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>name<span style="color:#f92672">.</span>value
</span></span><span style="display:flex;"><span>    command <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>search(<span style="color:#e6db74">&#34;src/.*</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">.py&#34;</span>, node<span style="color:#f92672">.</span>dumps())<span style="color:#f92672">.</span>group()
</span></span><span style="display:flex;"><span>    paths<span style="color:#f92672">.</span>append(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>fxn_name<span style="color:#e6db74">}</span><span style="color:#e6db74">/</span><span style="color:#e6db74">{</span>command<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> path <span style="color:#f92672">in</span> paths:
</span></span><span style="display:flex;"><span>    print(path)
</span></span><span style="display:flex;"><span><span style="color:#75715e">## hello/src/world.py</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## goodbye/src/world.py</span>
</span></span></code></pre></div><p>Not super proud of this but gets the job done for my use case - and when you&rsquo;re not making open source for others, you don&rsquo;t need to worry about other use cases :)</p>
<p>I&rsquo;ll definitely try to learn how to properly extract stuff using <code>redbaron</code> - but it got me to answer much faster than the <code>ast</code> library.</p>
]]></content:encoded>
    </item>
    <item>
      <title>API client design: how to deal with lots of parameters?</title>
      <link>http://localhost:1313/2020/12/api-client-params/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2020/12/api-client-params/</guid>
      <description>In February this year I wroute about how many parameters functions should have, looking at some other languages, with a detailed look at R. On a related topic &amp;hellip;
As I work on many R packages that are API clients for various web services, I began wondering: What is the best way to deal with API routes that have a lot of parameters?
The general programming wisdom I&amp;rsquo;ve seen is that a function should have no more than 3-4 parameters (e.</description>
      <content:encoded><![CDATA[<p>In February this year I wroute about <a href="https://recology.info/2020/02/how-many-parameters/">how many parameters functions should have</a>, looking at some other languages, with a detailed look at R. On a related topic &hellip;</p>
<p>As I work on many R packages that are API clients for various web services, I began wondering: What is the best way to deal with API routes that have a lot of parameters?</p>
<p>The general programming wisdom I&rsquo;ve seen is that a function should have no more than 3-4 parameters (e.g., <a href="https://stackoverflow.com/questions/174968/how-many-parameters-are-too-many">this long SO thread</a>, or <a href="https://softwareengineering.stackexchange.com/questions/331803/techniques-for-minimising-number-of-function-arguments">this one</a>). So should one do anything different from a normal function when that function is connecting to a web API route with a lot of parameters? I&rsquo;ve not found very much spilled ink on this exact topic, but I&rsquo;ll discuss what I have found.</p>
<h2 id="use-cases">Use cases?</h2>
<p>A Software Engineering StackExchange thread <a href="https://softwareengineering.stackexchange.com/questions/196895/how-to-handle-many-arguments-in-an-api-wrapper">How to handle many arguments in an API wrapper?</a> had a couple ideas. One idea is to consider use cases, and then make separate functions covering those use cases. This might work, but I haven&rsquo;t explored it thoroughly for a real API route yet. Pondering on it though I doubt this would work since you&rsquo;d have to pre-emptively think about all the different scenarios users might dream up, which seems like a fools errand.</p>
<h2 id="builder-pattern">Builder pattern</h2>
<p>Another concept brought up in the thread mentioned above was the <a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder pattern</a>. It&rsquo;s hard for me to understand the idea in abstract - <a href="https://medium.com/kkempin/builder-design-pattern-in-ruby-dfa2d557ff1b">here&rsquo;s a nicer discussion of this in Ruby</a>.</p>
<p>This is a good concept to know about, but I don&rsquo;t think is appropriate for the issue at hand, of how to handle many API parameters.</p>
<h2 id="named-parameter-map">Named parameter map</h2>
<p>Another idea in that thread was to use a named parameter map. In R this would look something like this (imagine a lot more parameters though):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>foo <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">function</span>(args) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;/some-api-route&#34;</span>, args)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>api_args <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">list</span>(query <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;*:*&#34;</span>, limit <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>my_args <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">modifyList</span>(api_args, <span style="color:#a6e22e">list</span>(query <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bears&#34;</span>, limit <span style="color:#f92672">=</span> <span style="color:#ae81ff">300</span>))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">foo</span>(my_args)
</span></span></code></pre></div><p>That is, the above would replace this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>foo <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">function</span>(query <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;*:*&#34;</span>, limit <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;/some-api-route&#34;</span>, <span style="color:#a6e22e">list</span>(query <span style="color:#f92672">=</span> query, limit <span style="color:#f92672">=</span> limit))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">foo</span>(query <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;*:*&#34;</span>, limit <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>)
</span></span></code></pre></div><p>So in the first code block the function no longer has a lot of parameters in it. The drawback of this in R (and I&rsquo;m sure is similar in other languages) is that users lose the autocomplete helpers that most modern IDE&rsquo;s and text editors have - helping users type less and quickly get a tip on what each parameter is intended to do and importantly (if the developer has documented the function well) what types the parameters expects and what (if any) options there are to pass to the parameter.</p>
<p>Of course a user can &ldquo;just&rdquo; read the docs to figure out what each parameter expects, but it sure can save a lot of time if the help is right there in the tooltips of the IDE/text editor. In addition, in R there&rsquo;s automated checking that parameters in functions are also documented, which is nice for making sure parameters and docs don&rsquo;t get out of sync. You&rsquo;d lose this by using a parameter map - though you could document the parameter map - and perhaps wire together some custom code to make sure the parameters in the parameter map are all handled by the function. This does seem like a lot of fuss though compared to simply having the parameters in the function itself.</p>
<p>This approach probably becomes more attractive if a client has many functions that take the same parameters - in which a named parameter map could handle the parameters and any logic behind checking those parameters.</p>
<h2 id="include-no-parameters-in-the-function">Include no parameters in the function</h2>
<p>In other words: Pass all parameters on to the API w/o including any of them in the function - i.e., let the API handle any problems in parameters.</p>
<p>Another approach I&rsquo;ve not seen written about but that I&rsquo;ve seen in code is having a rather lite wrapper around an API and letting the API itself sort out any problems due to user inputs.</p>
<p>An example is the <a href="https://gh.r-lib.org/">gh R package</a>, a client for the GitHub API. For query parameters you can pass in named parameters through the ellipsis <code>...</code>, all of which are passed as query parameters. The gh package does no checking of these parameters (that I know of); simply passes them to the GitHub API. The GitHub API happens to apparently ignore invalid (silently drop) parameters and invalid valuses of parameters (here, &ldquo;stuff&rdquo; is an invalid value for the <code>page</code> parameter).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>x <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">gh</span>(<span style="color:#e6db74">&#34;GET /users/{username}/repos&#34;</span>, username <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;gaborcsardi&#34;</span>, page <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;stuff&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">length</span>(x)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#&gt; 30</span>
</span></span></code></pre></div><p>I don&rsquo;t hate this solution, but I don&rsquo;t love it either. This approach is highly dependent on a well designed API that fails gracefully, with informative error messages and with correct status codes, etc. I would say  most APIs are not as nice as GitHub&rsquo;s, at least in the scientific API space in which I work.</p>
<p>One plus side of this approach is the R package gh only has one parameter (<code>...</code>) to handle all query parameters, so you do solve the too many query parameters problem.</p>
<p>Another upside to this approach is you do not have to keep up with any changes in parameters on each API route - for example, an API route could drop one parameter, and add another, and the R client wouldn&rsquo;t have to change anything (assuming the change in parameters wasn&rsquo;t associated with a change that breaks code in the client).</p>
<p>A major downside of this approach is that the user often has to mount a time-consuming expedition to figure out what parameters are accepted. Some API clients may document them, and some will simply direct users to the web APIs docs. I think this part alone makes this solution (include no parameters in the function) not a good one since the user experience can be so bad if the documentation is not good. And all developers know its much easier for their docs to get out of date than their code.</p>
<h2 id="include-some-parameters-in-the-function">Include some parameters in the function</h2>
<p>Another approach is to define some query parameters in the function, and handle all others via R&rsquo;s ellipsis (<code>...</code>) - or similar in other languages. I&rsquo;ve seen this relatively often and have used it myself. It&rsquo;s often used when there&rsquo;s a clear smaller set of important parameters - those can be put in the function as named parameters. And then there&rsquo;s a long tail of other parameters that the maintainer thinks are not likely to be used very often. Those can be looked up by the user in the API docs for whatever API the client interacts with.</p>
<p>An example of this is the rOpenSci package <a href="https://docs.ropensci.org/rtweet/">rtweet</a> - a client for the Twitter API. In the <a href="https://docs.ropensci.org/rtweet/reference/search_tweets.html#arguments">search_tweets() function</a> there are a half dozen or so named parameters in the function, but then the ellipsis handles all other parameters.</p>
<p>The drawback to this approach is that no two APIs behave the same way. In the case of Twitter they silently ignore/drop parameters they do not support (same as the GitHub API, see above). For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span><span style="color:#a6e22e">library</span>(rtweet)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">search_tweets</span>(<span style="color:#e6db74">&#34;hillaryclinton&#34;</span>, n <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>, foo <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bar&#34;</span>)
</span></span></code></pre></div><p>Works just fine even though <code>foo</code> is absolutely not a parameter supported by the Twitter API. They must ignore parameters they don&rsquo;t support. This is same behavior as the GitHub API we saw above.</p>
<p>In the case of Twitter and GitHub one might want to raise errors on unsupported parameters client side in rtweet to avoid any use confusion of parameters being silently dropped.</p>
<h2 id="grouping-similar-parameters-together">Grouping similar parameters together</h2>
<p>Many threads (e.g., <a href="https://softwareengineering.stackexchange.com/a/352676/329940">this one</a>) suggest that similar parameters could be grouped together to reduce the number of parameters passed to a function. For example, if a function has the parameters <code>latitude</code> and <code>longitude</code> you could group those into a single parameter called e.g., <code>coordinates</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span><span style="color:#75715e"># Original function, each parameter separate</span>
</span></span><span style="display:flex;"><span>foo <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">function</span>(latitude, longitude) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># do something with latitude/longitude</span>
</span></span><span style="display:flex;"><span>    latitude
</span></span><span style="display:flex;"><span>    longitude
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Modified function, grouping the two parameters into one</span>
</span></span><span style="display:flex;"><span>foo <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">function</span>(coordinates) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># do something with latitude/longitude</span>
</span></span><span style="display:flex;"><span>    coordinates<span style="color:#f92672">$</span>latitude
</span></span><span style="display:flex;"><span>    coordinates<span style="color:#f92672">$</span>longitude
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Though I&rsquo;ve not tried this approach myself, it might be a good compromise between a function not handling any parameters (i.e., just passing all to the web API unhandled) and handling every parameter individually.</p>
<h2 id="closing-thoughts">Closing thoughts</h2>
<p>The benefit of documenting API query parameters in a client package is that you can tell the user what each parameters expects in language they can understand. That is, if you simply direct users to the docs for the web API with which the client interacts, the API docs could be not very good and/or specify types expected that the user may not understand. In addition, there may be edge cases or similar with some parameters that are not documented in the API docs but that you can document in the client docs for each parameter.</p>
<p>I would say the vast majority of web API clients I use that do succeed in having very few parameters also have docs in which it&rsquo;s a nightmare trying to figure out what parameters each method accepts. That is, the pursuit of very few parameters at least is correlated with a very poor user experience  - in my experience.</p>
]]></content:encoded>
    </item>
    <item>
      <title>how many parameters?</title>
      <link>http://localhost:1313/2020/02/how-many-parameters/</link>
      <pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2020/02/how-many-parameters/</guid>
      <description>Functions can have no parameters, or have a lot of parameters, or somewhere in between. How many parameters is too many? Does it even matter how many parameters there are in a function?
There&amp;rsquo;s AFAIK no &amp;ldquo;correct&amp;rdquo; answer to this question. And surely the &amp;ldquo;best practice&amp;rdquo; varies among programming languages. What do folks say about this and what should we be doing in R?
From other languages Many of the blog posts and SO posts on this topic cite the book Clean Code by &amp;ldquo;Uncle Bob&amp;rdquo;.</description>
      <content:encoded><![CDATA[<p>Functions can have no parameters, or have a lot of parameters, or somewhere
in between. How many parameters is too many? Does it even matter how many
parameters there are in a function?</p>
<p>There&rsquo;s AFAIK no &ldquo;correct&rdquo; answer to this question. And surely the &ldquo;best
practice&rdquo; varies among programming languages. What do folks say about
this and what should we be doing in R?</p>
<h2 id="from-other-languages">From other languages</h2>
<p>Many of the blog posts and SO posts on this topic cite the book
<a href="https://www.goodreads.com/book/show/3735293-clean-code">Clean Code</a> by &ldquo;Uncle Bob&rdquo;. I&rsquo;ve not read the book, but
it sounds worth a read.</p>
<p><a href="https://hackernoon.com/object-oriented-tricks-3-death-by-arguments-d070ac86d996">Some of the arguments go like</a>: <em>too many arguments can</em> &hellip;</p>
<ul>
<li>makes it easier to pass arguments in the wrong order</li>
<li>reduce code readability</li>
<li>make it harder to test a function; it’s difficult/time consuming to
test all various combinations of arguments work together</li>
</ul>
<p>An <a href="https://www.exakat.io/how-many-parameters-is-too-many/">analysis was done</a> in 2018 of php open source projects, and they
found that the most common number of parameters was 5; functions with 10
parameters or more were found in &lt;20% of projects.</p>
<p>On the other side, <a href="https://stackoverflow.com/a/175087/1091766">some</a> argue that
you shouldn&rsquo;t worry so much about the correct
number of parameters, but rather make sure that all the parameters make sense,
and are documented and tested.</p>
<p>To the extreme, a number of people <a href="https://stackoverflow.com/a/175035/1091766">quote the Clean Code book</a>:</p>
<blockquote>
<p>The ideal number of arguments for a function is zero</p>
</blockquote>
<p>Some general threads on this topic:</p>
<ul>
<li><a href="https://softwareengineering.stackexchange.com/questions/145055/are-there-guidelines-on-how-many-parameters-a-function-should-accept">Software engineering Stackexchange</a></li>
<li><a href="https://stackoverflow.com/questions/174968/how-many-parameters-are-too-many">Stackoverflow</a></li>
</ul>
<h2 id="data">Data</h2>
<p>Data for this post, created below, is in the github repo <a href="https://github.com/sckott/howmanyparams">sckott/howmanyparams</a>.</p>
<h2 id="what-about-r">What about R?</h2>
<p>What do the data show in the R language? Just like the blog post on php above,
let&rsquo;s have a look at a lot of R packages to get a general data informed
consensus on how many parameters are used per function.</p>
<p>It&rsquo;s incredibly likely that there is a better way to do what I&rsquo;ve done
below; but this is my hacky way of getting to the data.</p>
<p>What I&rsquo;ve done in words:</p>
<ul>
<li>Get a list of all available package names on CRAN</li>
<li>Install about half of them (didn&rsquo;t do all cause it takes time and
I don&rsquo;t think I need all 15K packages to get a good answer)</li>
<li>List the exported functions in each package</li>
<li>Count the arguments (parameters) per function in each package</li>
<li>Visualize the results</li>
</ul>
<p>I ended up using 82489 functions across 4777 packages</p>
<p>Load packages</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span><span style="color:#a6e22e">library</span>(plyr)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">library</span>(dplyr)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">library</span>(tibble)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">library</span>(ggplot2)
</span></span></code></pre></div><p>Use a different path from my actual R library location to not pollute
my current setup, and put binaries into a temporary directory
so they are cleaned up on exiting R.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>path <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;/some/path&#34;</span>
</span></span><span style="display:flex;"><span>binaries <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">file.path</span>(<span style="color:#a6e22e">tempdir</span>(), <span style="color:#e6db74">&#34;binaries&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">dir.create</span>(path)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">dir.create</span>(binaries)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.libPaths</span>(path)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.libPaths</span>() <span style="color:#75715e"># check that the path was set</span>
</span></span></code></pre></div><p>Function <code>do_one()</code> to run on each package:</p>
<ul>
<li>try to load the package</li>
<li>if not found install it</li>
<li>get a vector of the exported functions in the package</li>
<li>count how many arguments each function has, make a data.frame</li>
<li>unload the package namespace</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>do_one <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">function</span>(pkg) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">requireNamespace</span>(pkg))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">install.packages</span>(pkg, quiet<span style="color:#f92672">=</span><span style="color:#66d9ef">TRUE</span>, verbose<span style="color:#f92672">=</span><span style="color:#66d9ef">FALSE</span>, destdir <span style="color:#f92672">=</span> binaries)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">on.exit</span>(<span style="color:#a6e22e">unloadNamespace</span>(pkg))
</span></span><span style="display:flex;"><span>  funs <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">paste0</span>(pkg, <span style="color:#e6db74">&#34;::&#34;</span>, <span style="color:#a6e22e">getNamespaceExports</span>(pkg))
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">enframe</span>(<span style="color:#a6e22e">vapply</span>(funs, <span style="color:#66d9ef">function</span>(w) {
</span></span><span style="display:flex;"><span>    tt <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">tryCatch</span>(<span style="color:#a6e22e">parse</span>(text <span style="color:#f92672">=</span> w), error <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(e) e)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">inherits</span>(tt, <span style="color:#e6db74">&#34;error&#34;</span>)) <span style="color:#a6e22e">length</span>(<span style="color:#a6e22e">suppressWarnings</span>(<span style="color:#a6e22e">formals</span>(<span style="color:#a6e22e">eval</span>(tt)))) <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  }, <span style="color:#a6e22e">numeric</span>(<span style="color:#ae81ff">1</span>)))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>do_one_safe <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">failwith</span>(<span style="color:#a6e22e">tibble</span>(), do_one)
</span></span></code></pre></div><p>Get a list of packages. First time running through I used <code>available.packages()</code> which
gets you all available packages. After installing packages though, I used
<code>installed.packages()</code> to get the list of packages I already installed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span><span style="color:#75715e"># pkg_names &lt;- unname(available.packages()[,&#34;Package&#34;])</span>
</span></span><span style="display:flex;"><span>pkg_names <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">unname</span>(<span style="color:#a6e22e">installed.packages</span>()[,<span style="color:#e6db74">&#34;Package&#34;</span>])
</span></span></code></pre></div><p>Run each package through the <code>do_one()</code> function. This had to be stopped and
re-started a few times. This failed for quite a few packages - I wasn&rsquo;t trying to get every single package, just a large set of packages to get an idea of what packages do on average.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>tbls <span style="color:#f92672">&lt;-</span> stats<span style="color:#f92672">::</span><span style="color:#a6e22e">setNames</span>(<span style="color:#a6e22e">lapply</span>(pkg_names, do_one_safe), pkg_names)
</span></span></code></pre></div><p>Combine list of data.frame&rsquo;s into one data.frame</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>df <span style="color:#f92672">&lt;-</span> dplyr<span style="color:#f92672">::</span><span style="color:#a6e22e">bind_rows</span>(tbls, .id <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;pkg&#34;</span>)
</span></span><span style="display:flex;"><span>readr<span style="color:#f92672">::</span><span style="color:#a6e22e">write_csv</span>(df, <span style="color:#e6db74">&#34;params_per_fxn.csv&#34;</span>)
</span></span></code></pre></div><blockquote>
<p>note: you can get this data at <a href="https://github.com/sckott/howmanyparams#how-many-parameters">sckott/howmanyparams</a></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>df <span style="color:#f92672">&lt;-</span> readr<span style="color:#f92672">::</span><span style="color:#a6e22e">read_csv</span>(<span style="color:#e6db74">&#34;~/params_per_fxn.csv&#34;</span>)
</span></span></code></pre></div><p>Visualize</p>
<p><strong>All functions across all packages</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span><span style="color:#a6e22e">ggplot</span>(df, <span style="color:#a6e22e">aes</span>(x <span style="color:#f92672">=</span> value)) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">geom_histogram</span>(bins <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">scale_x_continuous</span>(limits <span style="color:#f92672">=</span> <span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">30</span>)) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">theme_grey</span>(base_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>)
</span></span></code></pre></div><p><img loading="lazy" src="/2020-02-10-how-many-parameters/unnamed-chunk-5-1.png" alt="plot of chunk unnamed-chunk-5"  />
</p>
<p>The mean number of arguments per function across all packages was 4.4,
and the most common value was 3. The maximum number of arguments was
209, and there were 5306 functions
(or 6.4%) with zero
parameters.</p>
<p><strong>Mean params across functions for each pkg</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>df_means <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">group_by</span>(df, pkg) <span style="color:#f92672">%&gt;%</span> 
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">summarise</span>(mean_params <span style="color:#f92672">=</span> <span style="color:#a6e22e">mean</span>(value, na.rm<span style="color:#f92672">=</span><span style="color:#66d9ef">TRUE</span>)) <span style="color:#f92672">%&gt;%</span> 
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ungroup</span>()
</span></span><span style="display:flex;"><span><span style="color:#75715e"># arrange(df_means, desc(mean_params))</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ggplot</span>(df_means, <span style="color:#a6e22e">aes</span>(x <span style="color:#f92672">=</span> mean_params)) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">geom_histogram</span>(bins <span style="color:#f92672">=</span> <span style="color:#ae81ff">50</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">scale_x_continuous</span>(limits <span style="color:#f92672">=</span> <span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">30</span>)) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">theme_grey</span>(base_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>)
</span></span></code></pre></div><p><img loading="lazy" src="/2020-02-10-how-many-parameters/unnamed-chunk-6-1.png" alt="plot of chunk unnamed-chunk-6"  />
</p>
<p>Taking the mean within each package first pulls the number of arguments to the right some,
with a mean of 5 arguments, and the most common value at 4.</p>
<h2 id="thoughts">Thoughts</h2>
<p>In terms of getting around the too many arguments thing, there&rsquo;s talk of
using global variables, which seems like generally a bad idea; unless perhaps
they are environment variables that are meant to be set by the user in
non-interactive environments, etc.</p>
<p>Other solutions are to use <code>...</code> in R, or similarly <code>**kwargs</code> or <code>*args</code> in Python (<a href="https://pythontips.com/2013/08/04/args-and-kwargs-in-python-explained/">ref.</a>), or
the newly added <code>...</code> in Ruby (<a href="https://eregon.me/blog/2019/11/10/the-delegation-challenge-of-ruby27.html">ref</a>). With this approach you could have very few parameters
defined in the function, and then internally within the function handle any parameter
filtering, etc. The downside of this in R is that you don&rsquo;t get the automated
checks making sure all function arguments are documented, and there&rsquo;s no documented
arguments that don&rsquo;t exist in the function.</p>
<p>I&rsquo;m not suggesting a solution is needed though; there&rsquo;s probably no right answer, but rather lots of opinions.</p>
<p>Having said that, the average R function does use about 4 arguments, so if you
keep your functions to around 4 arguments you&rsquo;ll be approaching the sort of
consensus of a large number of R developers.</p>
<p>Last, I should admit that some of the functions in my packages have quite a lot
of parameters - which was sort of the motivation for this post - that is, to explore
what most functions do. For example, <code>brranching::phylomatic</code> has 13 parameters,
three functions in the <code>crevents</code> package have 24 parameters &hellip; and I wonder
about these types of functions. Should I refactor? Or is it good enough to make
sure these functions are thoroughly documented and tested?</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
